# Copyright (C) 2023 Red Hat, Inc., Jake Hunsaker <jhunsake@redhat.com>
# This file is part of the rig project: https://github.com/TurboTurtle/rig
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# version 2 of the GNU General Public License.
#
# See the LICENSE file in the source distribution for further information.

import random
import shutil
import string
import yaml

from rigging.commands import RigCmd
from rigging.exceptions import CannotConfigureRigError
from rigging import BaseRig


class CreateCmd(RigCmd):
    """
    This command is used to create a rig using a locally available yaml config
    file. Rigs monitor for certain conditions and then take specified actions
    once those conditions are met.

    A basic example of a valid yaml file for rig is as follows:

    name: myrig  # optional, name will be autogenerated if omitted
    monitors:
      logs:
        message: 'some message to match'
    actions:
      sos:
        report:
            plugins: kernel

    In other words the basic needs are at least one 'monitors' and 'actions'
    element, but rigs may specify any number of supported monitors and/or
    actions. See `man rig-create` for more information.

    Example create command, which requires root permissions:

    rig create -f ~/myrig.yaml
    """

    parser_description = 'Create a new rig to watch for events'
    root_required = True

    def execute(self):
        self.config = self.parse_config_yaml()
        self.name = self._generate_rig_name()

        self.base_config = self._generate_base_config()
        self._setup_logging()
        self.base_config['tmpdir'] = self.tmpdir
        self._create_rig()

    @classmethod
    def add_parser_options(cls, parser):
        parser.add_argument('-f', '--config-file', required=True,
                            help='A yaml file specifying the rig\'s '
                                 'configuration ')
        parser.add_argument('--foreground', default=False, action='store_true',
                            help='Run the rig in the foreground')

    def _generate_base_config(self):
        _base = self.config.copy()
        _base.pop('monitors')
        _base.pop('actions')
        for opt in self.options:
            if opt == 'config_file':
                continue
            if opt not in _base:
                _base[opt] = self.options[opt]
        return _base

    def _create_rig(self):
        self.logger.info(f"Setting up new rig '{self.name}'")
        try:
            base = BaseRig(config=self.base_config, logger=self.logger)
            for monitor in self.config['monitors']:
                base.add_monitor(monitor, self.config['monitors'][monitor])
            for action in self.config['actions']:
                base.add_action(action, self.config['actions'][action])
        except Exception as err:
            self.logger.error(f"Failed setting up rig: {err}")
            # cleanup the lingering temp directory directly
            try:
                shutil.rmtree(self.tmpdir)
            except Exception as err:
                self.logger.error(f"Could not remove temp directory: {err}")
            raise
        if ('foreground' not in self.config and
                not self.base_config['foreground']):
            base.detach()
            print(f"Created rig {self.name} successfully")
        self.logger.info('Rig successfully configured, starting now...')
        base.start_rig()

    def _generate_rig_name(self):
        if 'name' in self.config:
            return self.config['name']
        self.config['name'] = ''.join(
            random.choice(string.ascii_lowercase) for x in range(5)
        )
        return self.config['name']

    def parse_config_yaml(self):
        try:
            with open(self.options['config_file'], 'r') as cf:
                _config = yaml.safe_load(cf)
            return _config
        except Exception as err:
            raise CannotConfigureRigError(err)
