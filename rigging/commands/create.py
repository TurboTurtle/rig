# Copyright (C) 2023 Red Hat, Inc., Jake Hunsaker <jhunsake@redhat.com>
# This file is part of the rig project: https://github.com/TurboTurtle/rig
#
# This copyrighted material is made available to anyone wishing to use,
# modify, copy, or redistribute it subject to the terms and conditions of
# version 2 of the GNU General Public License.
#
# See the LICENSE file in the source distribution for further information.

import random
import shutil
import string
import yaml

from rigging.commands import RigCmd
from rigging.exceptions import CannotConfigureRigError, SocketExistsError
from rigging import BaseRig


class CreateCmd(RigCmd):
    """
    This command is used to create a rig using a locally available yaml config
    file (a "rigfile"). Rigs monitor for certain conditions and then take
    specified actions once those conditions are met.

    A basic example of a valid rigfile for rig is as follows:

    # myrig.yaml
    name: myrig  # optional, name will be autogenerated if omitted
    monitors:
      logs:
        message: 'some message to match'
    actions:
      sos:
        report:
            plugins: kernel

    In other words the basic needs are at least one 'monitors' and 'actions'
    element, but rigs may specify any number of supported monitors and/or
    actions. See `man rig-create` for more information.

    Example create command, which requires root permissions:

    rig create -f ~/myrig.yaml
    """

    parser_description = 'Create a new rig to watch for events'
    root_required = True

    def execute(self):
        self.config = self.parse_config_yaml()
        self.name = self._generate_rig_name()

        self.base_config = self._generate_base_config()
        self._setup_logging()
        self.base_config['tmpdir'] = self.tmpdir
        self._create_rig()

    @classmethod
    def add_parser_options(cls, parser):
        parser.add_argument('-f', '--config-file', required=True,
                            help='A yaml file specifying the rig\'s '
                                 'configuration ')

    def _generate_base_config(self):
        _base = self.config.copy()
        _base.pop('monitors')
        _base.pop('actions')
        for opt in self.options:
            if opt == 'config_file':
                continue
            if opt not in _base:
                _base[opt] = self.options[opt]
        return _base

    def _create_rig(self):
        try:
            base = BaseRig(config=self.base_config, logger=self.logger)
        except SocketExistsError:
            raise Exception(
                f"A rig with the name '{self.config['name']}' already exists"
            )
        except Exception as err:
            raise Exception(f"Could not initialize new rig: {err}")
        self.logger.info(f"Setting up new rig '{self.name}'")
        try:
            for monitor in self.config['monitors']:
                base.add_monitor(monitor, self.config['monitors'][monitor])
            for action in self.config['actions']:
                base.add_action(action, self.config['actions'][action])
        except Exception as err:
            self.logger.error(f"Failed setting up rig: {err}")
            # cleanup the lingering temp directory directly
            try:
                shutil.rmtree(self.tmpdir)
            except Exception as err:
                self.logger.error(f"Could not remove temp directory: {err}")
            raise
        try:
            base.detach()
            print(f"Created rig {self.name} successfully")
        except Exception as err:
            self.logger.error(f"Could not detach from console: {err}")
            raise
        try:
            base.start_rig()
            self.logger.info('Rig successfully configured, starting now...')
        except Exception as err:
            self.logger.error(f"Rig failed to start: {err}")

    def _generate_rig_name(self):
        if 'name' in self.config:
            return self.config['name']
        self.config['name'] = ''.join(
            random.choice(string.ascii_lowercase) for x in range(5)
        )
        return self.config['name']

    def parse_config_yaml(self):
        try:
            with open(self.options['config_file'], 'r') as cf:
                _config = yaml.safe_load(cf)
            for _ele in ['monitors', 'actions']:
                if _ele not in _config:
                    raise Exception(
                        f"Required section '{_ele}' missing from rigfile"
                    )
            return _config
        except Exception as err:
            raise CannotConfigureRigError(err)
